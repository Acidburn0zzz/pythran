Pythran User Manual
===================

So you want to write algorithms that are eas*y* to maintain as in p*y*thon and
you want per*for*man*c*e as in *for*tran or *c*++? Let give a try to pythran!
pythran is a python-to-c++ translator that turns python module into native c++
module. From a user point of view, you still ``import`` your module, but under
the hood... there is much more happening!

Dislaimer
---------

Pythran is *not* a full python-to-c++ converter, as in _shedskin_. Instead it
takes a subset of the python language and turns it into heavily templatized c++
code instantiated for your particular types.

Say hello to:

* functions (!)
* lambdas
* list comprehension
* map, reduce and the like

Say bye bye to:

* classes
* set
* dictionnaries
* exception
* dynamic typing

Installation
------------

Let us assume you're running a Debian/Ubuntu distrib. In that case, all you have to do is

	$> sudo apt-get install libboost-python-dev
	$> easy_install --prefix <my_prefix> codeply ply numpy networkx

Alternatively, ``ply`` is available though ``python-ply``, ``numpy`` from ``python-numpy`` and
``networkx`` from ``python-networkx``. Then set your ``PYTHONPATH`` appropriately,
something like

	$> export  PYTHONPATH=<my_prefix>/lib/python<my_version>/site-packages

And you're almost done! From the source directory, run

	$> python setup.py install --prefix=<my_prefix>

And set your path to 

	$> export PATH=$PATH:<my_prefix>/bin

It makes the ``pythran`` command available to you.

First Steps
-----------

To begin with, you need... a python function in a module. Something like

	<<dprod.py>>
	def dprod(l0,l1):
		return sum([x*y for x,y in zip(l0,l1)])

will be perfect. But due to \_o< typing, ``l0`` and ``l1`` can be of any type,
so pythran need a small hint there. Add the following line somewhere in your
file, say at the top head, or right before the function definition.

	#pythran export dprod(int list, int list)

This basically tells pythran the type of the forthcoming arguments.


Afterwards, frenetically type

	$> pythran dprod.py

\o/ a ``dprod.so`` native module has been created and you can play with it
right *now*. The speedup will not be terrible because of the conversion cost
from python to C++. So let's try again with a well-known example. Let me
introduce the almighty __matrix multiply__!

	<<mm.py>>
	def zero(n,m): return [[0 for row in xrange(n)] for col in xrange(m)]
	def matrix_multiply(m0, m1):
		new_matrix = zero(len(m0),len(m1[0]))
		for i in xrange(len(m0)):
			for j in xrange(len(m1[0])):
				for k in xrange(len(m1)):
					new_matrix[i][j] += m0[i][k]*m1[k][j]
		return new_matrix

This a slightly more complex example, as a few intrinsics such as ``xrange`` or
``len`` are used, with a function call and even nested list comprehension. But
pythran can make its way through this. As you only want to export the
``matrix_multiply`` function, you can safely ignore the ``zero`` function and
just add

	#pythran export matrix_multiply(float list list, float list list)

to the source file. Note how pythran can combine different types and infers the
resulting type. It also respects the nested list structure of python, so you
are not limited to matrices...

Enough talk, run 

	$> pythran mm.py

And be amazed by the generation of a ``mm.so`` native module that run around
20x faster than the original one. ``timeit`` approved!

Concerning Pythran specifications
---------------------------------

The ``#pythran export`` commands are critical to pythran. In fact if they are
missing, pythran will complain loudly (and fail miserably). So let us dive into
these complex language!

There is currently only one pythran command, the ``export`` command. Its syntax is

	#pythran export function_name(argument_type*)

where ``function_name`` is the name of a function defined in the module, and
``argument_type*`` is a comma separated list of argument types, composed of any
combination of basic types and constructed types. What is a basic type?
Anything that looks like a python basic type! Constructed types are either
tuples, introduced by parenthesis, like ``(int, (float, str))`` or lists,
introduced by the ``list`` keyword.

	argument_type = basic_type
				  | (argument_type*)	# this is a tuple
				  | argument_type list	# this is a list

	basic_type = bool | int | long | float | str

Easy enough, isn't it?

Advanced Usage
--------------

A failing compilation? A lust of c++ tangled code? Give a try to the ``-E``
switch that stops the compilation process right after c++ code generation, so
that you can inspect it.

Want more performance? Big fan of ``-Ofast -march=native``? pythran
automagically forwards these switches to the underlying compiler!


Troubleshooting
---------------

Plenty of them! Seriously, pythran is pre-alpha software, so it will crash. You
must make it abort in unusual ways! And more important, you must provide
feedback to serge_sans_paille using its email serge.guelton@telecom-bretagne.eu
or the IRC channel #pythran.

**glhf!**
