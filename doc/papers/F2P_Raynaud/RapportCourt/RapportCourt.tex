\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}   
\usepackage[T1]{fontenc}      
\usepackage[francais]{babel}  

\usepackage{url}

\usepackage{graphicx}

\usepackage[a4paper]{geometry}

\title{Pythran : Rapport court}           
\author{Alan Raynaud}
\date{}                      

\sloppy 

\begin{document}

%Page de garde

\maketitle                  

\tableofcontents            

\clearpage

\section{Analyse bibliographique}             

\subsection{Introduction : du Python et des performances}

Python est un langage interprété conçu pour faciliter le développement mais pas pour obtenir des hautes performances. L'exécution d'algorithmes est généralement plus lentes qu'avec d'autres langages\cite{PythonPerf}.

TODO : Question de la nécessité de la performance + temps d'execution vs temps de dev

\subsection{Optimisation dans l'utilisation de python}

\label{OptCode}

\subsubsection{Améliorer les performances en améliorant le code}

Python permet génalement de résoudre un même problème de plusieurs façons. Si le choix d'un bon algorithme est crucial, la façon dont est implémenté cet algorithme peut faire varier considérablement les performances du programme final. C'est pourquoi il existe un ensemble de bonne pratiques permettant d'améliorer les performances de son code\cite{PythonSpeed}.

Exemples :
\begin{itemize}
\item Concaténer des strings avec .join() plutôt qu'avec l'opérateur +.
\item Utiliser plusieurs affectations plutôt qu'une affectation multiple : a=x;b=y; plutôt que a,b=x,y.
\item Utiliser les opérateurs propres au langage plutôt que les fonctions lamda : operator.add plutôt que lambda x,y : x+y.
\end{itemize}

\subsubsection{Iterateurs et generateur}

Dans la boucle de l'exemple suivant, python génère la liste  [1..100] puis créé un objet iterateur qui permet de parcourir un à un les élements de cette liste.

\begin{verbatim}
for i in range(100):
  print i
\end{verbatim}

On se rend compte dans cet exemple qu'il n'était pas nécessaire d'avoir toute la liste en mémoire. En effet, un seul élement est utilisé à la fois, et chaque élément n'est utilisé qu'une seule fois.

C'est pourquoi il existe en python des générateurs. Les générateurs permettent de réaliser des iterateurs qui ne parcourent pas un ensemble, mais génèrent les éléments de l'itération au fur et à mesure. Quand on utilise un iterateur produit par un generateur, il n'y a toujours qu'une seule valeur en mémoire : celle actuellement utilisée.

Python fournit également des iterateurs se comportant comme ceux produits par des générateurs : 

\begin{itemize}
  \item xrange qui se comporte comme range, mais ne créé pas de liste en mémoire
  \item les iterateurs du module itertools comme imap et product
\end{itemize}

Afin de considérer l'intérêt en terme de performances, on peut considérer la figure~\ref{GenExpMapImapPy} , qui montre les différences de temps d'exécution entre trois implémentations du calcul de la somme des carrés des N premiers entiers. 

\begin{figure}[h]
  \includegraphics[scale=0.5]{./Pictures/GenExpMapImapPy}
  \caption{Compaison de performances entre trois implémentations en python}
  \label{GenExpMapImapPy}
\end{figure}

Dans chaque cas, le temps de l'execution de 100 itérations du même programme est mesuré grâce au module timeit.

\begin{verbatim}
time100 = timeit.timeit('Expression', number=100)
\end{verbatim}

La première implémentation utilise un générateur :

\begin{verbatim}
sum(x*x for x in xrange(N))
\end{verbatim}

Le générateur créé permet de ne produire les carrés qu'au fur et à mesure de la sommation. A un instant donné, il n'y a qu'un seul carré en mémoire.


La seconde implémentation utilise l'operateur imap qui applique une fonction à un iterateur pour produire un nouvel iterateur :

\begin{verbatim}
sum(imap(lambda x:x*x, xrange(N)))
\end{verbatim}

Cette implémentation est moins performante que la première car elle utilise des appels de fonction, qui sont couteux en python.


La troisième implémentation utilise l'operateur map qui applique une fonction à un iterateur pour produire une liste :

\begin{verbatim}
sum(map(lambda x:x*x, xrange(N)))
\end{verbatim}

Dans cette implémentation, la liste des carrés est créée avant la sommation. C'est l'opération de création de l'espace mémoire nécessaire pour la stocker qui est couteuse et diminue les performance par rapport à la seconde implémentation.

\subsection{Optimisation à partir du code python}

Les méthodes d'amélioration des performances présentées en \ref{OptCode} nécessitent d'effectuer des modifications au niveau du code source. Les gains en temps d'exécution se feront donc au prix d'augmentation du temps de développement. Il existe cependant des outils qui permettent d'augmenter les performances d'un programme sans avoir à modifier le code source.

\subsubsection{Optimisation de l'interpréteur}

CPython est l'implémentation de référence du langage python. Il en existe cependant d'autre comme Jython écrit en Java et IronPython, l'implémentation de python pour .NET. Le projet Pypy, quant à lui, a pour but d'obtenir une implémentation de python plus performante que CPython.

Un programme écrit en python pour CPython peut être exécuté avec Pypy sans modification\footnote{Il existe quelques incompatibilités dans des cas particuliers, souvent liées à des différence de stratégie des ramasse-miettes\cite{PypyDiff}.} et sera en moyenne 5,5 fois plus rapide\cite{PypySpeed}.

\subsubsection{La solution pythran : compiler en code natif}

L'outils pythran permet de traduire un module python en C++ pour pouvoir ensuite être compilé en code natif. Afin d'être utilisable par pythran, le code source doit seulement être annoté de descriptions d'interface. Le résultat est un module python en code natif qui peut être utilisé depuis un programme python usuel.

Pythran ne traduit qu'un sous-ensemble de python. En particulier, les classes ne sont pas gérées. Cela destine pythran à être utilisé pour l'optimisation d'algorithmes dont les temps d'exécution sont critiques pour le programme les utilisant.

La figure~\ref{RangeXrangePyCpp} permet de comparer les performances entre un programme en python et son équivalent en C++.

\begin{figure}[h]
  \includegraphics[scale=0.5]{./Pictures/RangeXrangePyCpp}
  \caption{Comparaison de performances entre python et C++ compilé avec et sans le flag -O3.}
  \label{RangeXrangePyCpp}
\end{figure}

Les programme en python sont les suivants :

\begin{verbatim}
  sum(range(N))
\end{verbatim}

\begin{verbatim}
  sum(xrange(N))
\end{verbatim}

et leurs équivalents en C++ sont :

\begin{verbatim}
  pythonic::sum(pythonic::range(N))
\end{verbatim}

\begin{verbatim}
  pythonic::sum(pythonic::xrange(N))
\end{verbatim}

où pythonic est le namespace de pythonic++ (cf. \ref{pythonicpp} p. \pageref{pythonicpp}).

Les temps en python sont de nouveau mesurés avec timeit.timeit() et les temps en C++ sont mesurés avec clock().

\begin{figure}[h]
  \includegraphics[scale=0.5]{./Pictures/RangeXrangeCppO3}
  \caption{Comparaison entre range et xrange en C++ avec le flag O3.}
  \label{RangeXrangeCppO3}
\end{figure}

On remarque que, contrairement à ce à quoi on pouvait s'attendre, les implémentations en C++ ne sont pas toujours plus rapides que celles en python. Dans le cas du xrange, le programme en python est légèrement plus performant que celui en C++. Cependant, l'optimisation du compilateur C++ permet de réduire de façon drastique le temps d'exécution. Enfin, le gain réalisé en remplaçant range par xrange se retrouve également en C++, comme le montre la figure~\ref{RangeXrangeCppO3}. 

De cela on peut en conclure que pythran peut augmenter les performances d'un algorithme sur trois axes :

\begin{itemize}
  \item Optimisation du code d'origine, par exemple en utilisant des iterateurs comme xrange ou imap plutôt que range ou map.
  \item Traduction en code C++ pour pouvoir être compilé en code natif, en général plus rapide que du code interprété.
  \item Possibilité de bénéficier des optimisations supplémentaires du compilateur C++.
\end{itemize}


Pythran permet également d'annoter le programme de directives OpenMP, qui permettent de paralléliser les opérations qui peuvent l'être. Une bonne utilisation des directives OpenMP permet ainsi d'augmenter encore la vitesse d'execution d'un facteur x2 à x4\cite{PythranRenpar}.

\section{Analyse du problème}

Le code python lu par pythran est réprésenté sous forme d'un arbre syntaxique abstrait (AST) dont les noeuds représentent des opérateurs et les feuilles des opérandes. C'est sur cet arbre que pythran travaille pour optimiser le programme et le traduire en C++.

\subsection{Transformations de l'AST}

Avant de produire la traduction C++, pythran peut effectuer des opérations sur l'AST. Ces opérations visent à apporter des modifications ne changeant pas les résultats produits par le programme, mais utilisant des combinaisons d'opérateurs plus performantes celles initialement utilisées. On appelle ce type de modification une transformation de l'AST.

\subsubsection{Recherche de transformations valide}

La recherche de transformations pertinentes nécessitent d'avoir des connaissance pointues sur le coût des différentes opérations effectuées par un même opérateur. Par exemple, c'est parce que l'allocation d'une grande quantité de mémoire a un coût prohibitif que les transformation du type range -> xrange permettent un gain de performances.

Un autre problème est celui de la recherche de la validité d'une transformation. On a vu qu'une transformation consiste à remplacer une combinaison d'opérateurs par une autre combinaison équivalente. Or, cette équivalence peut n'être vérifiée que sous certaines conditions. La transformation n'est alors valide que dans les cas où ces conditions sont toutes vérifiées.

Dans le cas de xrange, une condition suffisante pour que la transformation range -> xrange soit valide est que le résultat produit par range ne soit jamais modifié. Ce qui serait par exemple le cas dans l'exemple suivant\footnote{En supposant que range(100) soit bien une opération produisant la liste [1..100].} :

\begin{verbatim}
  for i in range(100):
    f(i)
\end{verbatim}

Ceci peut donc être remplacé par

\begin{verbatim}
  for i in xrange(100):
    f(i)
\end{verbatim}

\subsubsection{Le problème du contexte}

Un obstacle majeur est qu'il n'est pas trivial de savoir si les conditions de validité de la transformation sont remplies.

Par exemple, il est possible d'appliquer la transformation range -> xrange au programme suivant. Mais pour pouvoir savoir cela, il faut vérifier dans le reste du code pour s'assurer que la liste assignée à la variable l n'est jamais modifiée.

\begin{verbatim}
  l = range(100)
  .
  .
  .
  for i in l:
    f(i)
\end{verbatim}

Un autre problème vient du fait que dans l'AST, un opérateur est représenté par son nom, ce qui permet la situation de l'exemple suivant, où la transformation range() -> xrange() n'est pas valide dans la boucle for.

\begin{verbatim}
  def g(n):
    return [9001,n,27,42]
  .
  .
  .
  range = g
  .
  .
  .
  for i in range(100):
    f(i)
\end{verbatim}

Avant d'effectuer la transformation, il faut donc analyser le programme pour déterminer dans quels cas la transformation est valide. Dans pythran, c'est ce que réalisent les analyses, qui parcourent et annotent l'AST. Les transformations appliquées ensuites utilisent les annotations laissées par les analyses.

Un exemple simple est celui de la réduction des expressions constantes. Une analyse parcourt l'AST pour déterminer quels noeuds correspondent à des expressions constantes. Une transformation peut ensuite être appliquée à ces noeuds pour les réduire en feuille.

\subsection{Compilation du code optimisé}

\label{pythonicpp}

C'est à partir de l'AST optimisé que pythran génère le code C++. Pour cela, il utilise pythonic++, un ensemble de headers C++ qui contiennent les équivalents en C++ des opérateurs et des collections natives au python. 

Pour qu'un module de la bibliothèque standard de python puisse être utilisé dans du code traduit par pythran, il faut donc qu'un équivalent de ce module ai été développé pour pythonic++.

En particulier, le module itertools n'est pas encore implementé dans pythonic++, ce qui empêche d'utiliser des fonctions comme imap ou product.

\section{Plan de travail}

L'ordre envisagé pour le plan de travail prend en compte plusieurs paramètres :

\begin{itemize}
\item Certains travaux dépendent des résultats des autres. En particulier, la plupart des transformations de l'AST visent à utiliser des fonctions du module itertools dès que cela est possible. Ces transformations ne peuvent donc être implémentées qu'une fois le module itertools disponible dans pythonic++.
\item Certains travaux sont plus simples et permettent d'assimiler les concepts et outils nécessaires à la réalisation des travaux plus complexes du même type. Par exemple, la transformation de range en xrange est complexe et devrait donc être abordée après que la transformation de generator expression en imap ait été complétée.
\end{itemize}

\subsection{Implémentation du module Itertools}

\subsubsection{Méthodologie}

La méthodologie utilisée pour l'implémentation du module itertools est une itération des étapes suivantes :

\begin{enumerate}
\item Déterminer une fonction à implémenter.
\item Écrire des tests.
\item Implémenter la fonction en C++ dans pythonic++.
\item Tester la fonction pour vérifier qu'elle produit le résultat attendu pour tout les cas de test.
\item Tester les performances de la fonction et vérifier qu'il n'y a pas d'opération anormalement coûteuse avec l'outils Callgrind. 
\end{enumerate}

\subsubsection{Priorités}

Les opérateurs à implémenter en priorités sont ceux nécessaires à l'implémentations des nouvelles transformations :

\begin{itemize}
  \item imap
  \item product
  \item ifilter
\end{itemize}


\subsection{Transformation de l'AST}

Une seconde partie du travail consistera à mettre au point des transformations de l'AST pertinentes. En particulier, il faudra déterminer dans quel cas elles sont valides et s'assurer de ne les appliquer que dans ces cas.

\subsubsection{Les generator expressions}

En python, les generator expression sont plus performantes que l'utilisation de map ou imap. Cependant, cela est lié au cout prohibitif d'un appel de fonction en python. Une fois traduit en C++, ce surcoût devrait être moindre et devrait rendre l'implémentation de imap plus performante que l'équivalent des generator expressions.

Il sera alors pertinent de remplacer

\begin{verbatim}
  (g(a,b,c...) for a in A if fa(a) for b in B if fb(a,b) for c in C if fc(a,b,c) ... )
\end{verbatim}
 
par

\begin{verbatim}
  imap(lambda a,b,c... : g(a,b,c...), ifilter(lambda a,b,c... : fa(a) and fb(a,b) and fc(a,b,c)..., product(A,B,C...)))
\end{verbatim}

Cette transformation est toujours valide et ne nécessitera pas d'écrire une analyse.

Il faudra donc implémenter la transformation correspondante, et effecter des tests pour vérifier qu'elle apporte bien un gain de performances.

\subsubsection{Le cas xrange}

Les exemples précédents ont montré que la transformation range -> xrange n'est pas toujours valide. Il faudra donc :

\begin{enumerate}
  \item Identifier la plupart des cas dans lesquels la transformation est valide.
  \item Écrire une ou des analyses permettant d'identifier ces cas.
  \item Implémenter la transformation.
\end{enumerate}

On note en particulier qu'il est à priori très difficile de trouver une analyse permettant de trouver tous les cas dans lesquels la transformation serait valide.

Par exemple, il serait valide de remplacer range par xrange dans la boucle for de l'exemple suivant, mais très difficile de le déterminer.


\begin{verbatim}
def g(n):
  return map(lambda x : - 1 * x, xrange(0,-n,-1))

range = g

for i in range(100):
    f(i)
\end{verbatim}

\subsubsection{Contraintes}

Le analyse et transformations de pythran sont écrites en python. Tout code produit doit être conforme à pep8, un ensemble de bonnes pratiques python. Pour cela, avant d'être commité, tout code ajouté doit être validé par l'outils pep8.

\clearpage

\appendix


\listoffigures            

\bibliographystyle{plain}
\bibliography{RapportCourtBib}

\end{document}

